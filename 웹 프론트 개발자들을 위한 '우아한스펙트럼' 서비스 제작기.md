[웹프론트 개발자들을 위한 '우아한스펙트럼' 서비스 제작기](https://www.youtube.com/watch?v=-O-z3W4S6xc&list=PLgXGHBqgT2TundZ81MAVHPzeYOTeII69j&index=37)

### 웹프론트테크트리

    - 전사 프론트엔드 기술 파악
    - 각 기술의 장/단점과 사용 이유 분석
    - 우형 웹프론트 미래 기술의 로드맵

    => 프론트 개발자끼리 프로덕트를 만들자

### 좋은 그라운드룰

#### 일하는 자세

- 왜? 라는 질문을 많이 하자.
- 기획에도 적극적으로 참여하자.
- 안된다고 하기 보다는 개선할 수 있는 방안을 고민하고 제시하자.
- 본인의 업무가 아니더라도, 팀 내 프로젝트나 업무에 관심을 갖자.

#### 함께 공유하기

- 사소한 내용이라도 슬랙에 공유하자.
- 개인의 도메인 지식이 팀의 지식이 될 수 있도록 하자.
- 매주 서로 작업한 내용을 공유
- 모르는 것이 있다면 이해될 때까지 질문하자.
- 같은 질문이 100번 되더라도, 확실히 답변해주자.

 <br>
<br>
<br>

### gitlab flow

main : 모든 작업이 담긴 메인 브랜치 - 모든 코드가 피처단위로 작업되어 머지되는 곳, 해당 코드들로 하여금 배포본을 만들어 배포한다.

feature/{JIRA 티켓 명} : 피쳐 단위의 브랜치 작업(story, task, sub-task) - story, task, sub-task 단위의 작업을 진행할 때 제작하는 피쳐 브랜치, 해당 브랜치를 main branch를 PR로 날린다. (feature 브랜치는 여러개가 될 수 있다. 또한, 각 사용자의 origin branch 혹은 local에 존재해야 한다.

release/{배포일자} : 배포가 진행되는 일자에 해당하는 작업의 모음, 실제 운영에 배포되어 유저가 기능을 사용하는 코드의 집합 - 해당 날 실제 배포가 진행되야 하는 작업이 담긴 브랜치, 해당 브랜치를 기준으로 베타 배포를 진행하며 베타에서 QA를 거친 후 완전한 코드를 Production으로 merge한다.

hotfix/{JIRA 티켓 명} : Pre production 브랜치에서 버그가 생길 경우 생성하여 대응 - Pre production으로 티켓을 만들고 Pre Production으로 MR을 요청한다. 이후 적용되어 production으로 merge되면 해당 작업을 range cherry-pick으로 mani에 적용한다.

<br>

<br>

#### 프로토타입 만들기

<br>
<br>

#### 서비스 기획

프론트에서 사용하고 있는 라이브러리 정보 보여주기
기대효과 : 프로젝트에 도입할 신기술을 고민하거나 기술적 챌린지를 할 때 도움을 받을 수 있다.
프론트엔드 어플리케이션 아키텍쳐를 고민해볼 수 있다.
사내 기술 트렌드를 확인해볼 수 있다.
최적화/성능에 관련된 각 팀들의 지표를 확인해볼 수 있다.

 <br>
<br>

### nest.js 채택 이유

- 프론트엔드 개발자에게 익숙한 Node.js를 기반으로 하며 TypeScript를 기본 지원한다.
- 모듈식 아키텍처를 기반으로 하여 재사용성이 용이하며, 확장성이 좋다. (애플리케이션을 모듈로 구분 가능, 공통사용모듈은 분리해서 재사용 가능, 기능추가시 모듈을 별도로 만들어 주입하면 됨)
- 미들웨어, 데이터베이스 등의 기능을 기본 제공한다.

### next.js 채택 이유

- zero config를 지향한다. (환경세팅부터 개발서버나 빌드서버까지 간단한 명령어로 사용)
- 문서와 생태계가 잘 갖춰져 있으며, 일정 수준 컨벤션이 강제된다.(빠르게 진행 가능)
- 우아한 스펙트럼은 정적 사이트로 Next.js의 SSG를 활용하면 좋겠다.

<br>
<br>

### 서버

#### batch

- 레포지토리 정보
  사내 레포지토리 정보를 불러온다.
  Gitlab API를 사용
- 라이브러리 정보
  사내 프론트엔드 레포지토리에서 사용하는 npm 라이브러리 정보를 불러온다.
  해당 라이브러리에 대한 추가 정보는 npm 레지스트리에서 불러온다.

=> 한번에 요청시 문제 발생 : job을 순차적으로 실행, gitlab API사용

#### 데이터 스키마 변경

- 누군가 entity에 신규 column생성 - 신규 column은 운영 DB 추가 요청 필요
  따라서, DB변경시 문서에 기록하기, 서버 MR templete 체크박스 만들기

### 업데이트 상황을 문서 기록과 팔로우업을 해야 유지보수가 잘 된다.

<br>
<br>

<프론트 편>

### 기존 CSR 배포 방식

- 루트 경로의 index.html 하나만 설정(<root>/index.html)

하지만, Next.js SSG빌드시 경로에 따라 생성되는 N개의 정적 파일에 대한 처리 필요 - 운영 환경 설정에 대한 이해 부족, 지속적인 유지보수의 어려움
(pages.index.html / pages/404.html / pages/libraries.html)

이전 방식은

- getStaticPatch 함수로 미리 페이지를 생성하는가 ? X
- getStaticProps 함수로 빌드 시점에 데이터를 불러오는가? X

사내 정책상(망 분리)로 빌드 시점에 data fetching을 해올 수 없기 때문

그렇다면

- quert param을 받아 클라이언트에서 라우팅을 처리하는가 ? O
- 서버 API를 클라이언트에서만 호출하는가 ? O
- 사용자 인터랙션이 많은 동적 페이지인가? O
  => SSG를 쓸 필요가 없다.

전사레포지토리 정보는 거의 바뀌지 않을 거면 배포도 자주 필요없다. SSG로 하자.

매일 batch app을 돌리니 데이터가 업데이트 된다.

그럼 정적 사이트의 성능상의 이점을 챙기면서도 배포없이 데이터를 업데이트 해줄 수 있는 ISR로 하자

만들다보면 검색기능도 필요, 사용자 인터랙션도 생김 -> CSR

워크샵을 통해 하루종일 개발 ..

  <br>
<br>

### 기술인기차트

React - express - react-query - next

#### 시각적 지표

필터링, 정렬 기능 개선 + 라이브러리 비교 가능

#### 기술 토론장

코멘트, 추천 기능

#### 실무에 확장 적용

#### <박이상의 느낀점🎁>

이해하지 못하는 용어는 나중으로 미루지 말고 지금 찾아봐야 겠다는 생각이 든다. 동적페이지와 정적페이지도 남에게 설명할 수 있는 정도의 이해는 아니니 근본지식이 중요하다는 것을 깨달았다. 그라운드룰을 보며 다음 프로젝트에 저 룰들을 꼭 적용해야겠다는 결심이 들었다. 프론트엔드 개발자들이 모여 프로젝트를 진행해도 재밌겠다는 부러움과 더불어 좋은 곳에 취직해야 더 발전한다는 깨달음. nest.js와 next.js의 장점을 보니 사용해보고 싶다 !
